테스트 커버리지 Test coverage - 소프트웨어의 테스트 범위 측정
  1. 기능 기반 커버리지 - 실제 테스트가 수행된 기능의 수를 측정 (100% 달성이 목표)
  2. 라인 커버리지 - 수행한 소스 코드의 라인 수를 측정(단위 테스트의 척도로 삼기도 함)
  3. 코드 커버리지 - 구문, 조건, 결정 등의 구조 코드 자체가 얼마나 테스트 되었는지
       3-1.구문 커버리지 - 모든 구문에 대해 한 번 이상 수행
       3-2.조건 커버리지 - 모든 개별 조건식에 대해 수행
       3-3.결정 커버리지 - 모든 분기문에 대해 수행
       3-4.조건/결정 커버리지 - 조건 결정을 최소한의 조합으로 달성(2개의 테스트로 달성 가능)

오류 제어기법
  1.전진에러수정 FEC FORWARD ERROR CORRECTION - 오류발생 검출 수정 (hamming code)
  2.후진에러수정 BEC BACKWARD ERROR CORRECTION - 재전송 (parity, blocksum, CRC)

HDLC 프로토콜
  프레임 구조에서 control(8비트) 의 프레임에 관하여
    1.정보 프레임 0으로 시작 - 네트워크 계층에서 내려옴 패킷을 전송
      1-1.3비트 순서번호를 이용한 슬리이딩 윈도우 프로토콜 사용 / 순서 번호는 비트 수가 3개이므로 0~7 순서 번호 8개를 순환
    2.감독 프레임 10으로 시작 - 정보 프레임에 대한 응답 기능을 수행
      2-1.응답 기능 수행 / 긍정, 부정 프레임으로 구분 type이 x0이면 모두 긍정 x1이면 모두 부정
    3.비번호 프레임 11로 시작 - 연결 설정 제어
      3-1.순서번호 없음 / 연결제어, 비연결형 데이터 전송 
        연결모드 1. 정규응답(허락필요) / 비동기 균형(두개 호스트 대등) / 비동기 응답(허락없이)

암호 알고리즘
  양방향 - 대칭키(개인키 / 비공개키)                              / 비대칭키(공개키)
    스트림 암호(LFSR, RC4) 블록암호(DES ,3DES, AES, SEED, ARIA)  / RSA, ECC, ELGAMAL, 디피-헬만
  단방향 - 해시함수

해시의 특징
  평문의 길이에 상관없이 해시 결과 길이 모두 같음
  정보 위변조 확인 가능 전자화폐 전자상거래에서 사용

하향식 방식 통합 테스트
  위에서부터 ~ 아래로(만들지 못한 것 = [스텁]이 팰요 - 완성은 안됐지만 예시파일같은 것 / 구현 나중에 할게)

상향식 방식 통합 테스트
  아래서부터 ~ 위로(아래는 됐는데 위에는 아직 못만듬 - [드라이버]가 필요)

모듈 응집도
  우논시절교순기

정규형 함 보기

OSPF(Open Shorttest Path First) - 최적의 경로 / 최단경로 구축 / Dijkstra 알고리즘

●(theta join)세타조인(R▷◁(r 조건 s)S):
-조인에 참여하는 두 릴레이션의 속성 값을 비교하여 조건을 만족하는 투플만 반환한다.


●(inner join)내부조인(동등조인)(R▷◁(r=s)S):
-동등조인의 결과 릴레이션의 차수는 첫 번째 릴레이션과 두 번째 릴레이션의 차수를 합한 것.


●(natural join)자연조인(R▷◁N(r,s)S):
-동등조인에서 조인에 참여한 속성이 두 번 나오지 않도록 중복된 속성(두 번째 속성)을 제거한 결과를 반환


●(outer join)외부조인:
-왼쪽 외부조인(left outer join):
왼쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.

-오른쪽 외부조인(right outer join):
오른쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.

-완전 외부조인(full outer join):
양쪽 투플 기준으로 자연조인 시 실패한 투플을 모두 보여주되 값이 없는 대응 속성에는 NULL 값을 채워서 반환한다.


●(semi join)세미조인:
-자연조인을 한 후 두 릴레이션 중 한쪽 릴레이션의 결과만 반환

LRU (Least Recently Used):
가장 오랫동안 사용되지 않은 페이지를 교체합니다.
'최근에 언제 사용되었는가'를 기준으로 합니다.
가장 오래전에 접근된 페이지를 먼저 교체합니다.
LFU (Least Frequently Used):
사용 빈도가 가장 적은 페이지를 교체합니다.
'얼마나 자주 사용되었는가'를 기준으로 합니다.
참조 횟수가 가장 적은 페이지를 먼저 교체합니다.
NUR (미래추정)
FIFO (선입선출)
OPT (최적) - 앞으로 사용하지 않을 - 하지만 실제로 구현 불가

